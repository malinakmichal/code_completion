prefix,suffix,label,label_prefix,result,CHRF,exact_match,correct_syntax,rougeL,correct_code
"
impor","import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochÃ¡ch
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",t pandas as pd,impor,t pandas as pd,67.43033470401954,True,True,0.75,True
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network
","data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochÃ¡ch
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",,,,0.0,nan,nan,0.0,True
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)
","    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochÃ¡ch
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",,,"    def forward(self, x):",1.937984496124031,False,False,0.0,False
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            ","        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochÃ¡ch
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",x = self.drop(x),            ,            x = self.drop(x),100.0,True,True,1.0,True
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochÃ¡ch
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
    ","            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",    if self.dropout_prob:,    ,        x = F.relu(self.conv1_drop(x)),23.58290417257619,False,True,0.1818181818181818,False
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = ","        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochÃ¡ch
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",nn.Dropout(p=dropout_prob),        self.drop = ,"        self.fc3 = nn.Linear(16, 10)",14.277741359120258,False,True,0.3076923076923076,False
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense ","model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochÃ¡ch
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)","= DenseNetwork(training_loader, validation_loader).to(""cuda"")",model_dense ,,1.1778563015312131,False,True,0.0,False
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class D","    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochÃ¡ch
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",enseNetwork(Network):,class D,DenseNetwork(nn.Module):,47.4576302709702,False,False,0.3333333333333333,False
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from sklearn.linear_model import Ridge

def g","    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",et_model(data):,def g,,2.109704641350211,False,True,0.0,False
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
impo","import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",rt math,impo,rt numpy as np,11.793166011490776,False,True,0.0,True
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, me","import math
import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",an_squared_error,"from sklearn.metrics import mean_absolute_error, me",,0.6535947712418302,False,True,0.0,False
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from skle","
def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",arn.linear_model import Ridge,from skle,import numpy as np,14.65831677995379,False,True,0.2,False
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)
","    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",,,    return model,0.0,False,False,0.0,False
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_","import math
import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)","absolute_error, mean_squared_error",from sklearn.metrics import mean_,from sklearn.metrics <|endoftext|>,32.673330842259915,False,False,0.4285714285714285,False
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.dr","    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",op(columns='days'),    X = data.dr,"    X_train, X_test, y_train, y_test = train_test",6.193693693693694,False,True,0.1333333333333333,False
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from ","
def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",sklearn.linear_model import Ridge,from ,import numpy as np,14.65831677995379,False,True,0.2,False
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape","    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
","[0]//2, kernel.shape[1]//2]",        return [kernel.shape,"                // 2, kernel.shape[1] // 2]",53.7223181515666,False,False,0.7142857142857143,True
"'''Filter'''
import numpy as np

def","    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
", get_center(kernel):,def,,0.0,False,True,0.0,False
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])

","def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
",,,"def apply_filter_2d(image: np.array, kernel: np.array)",2.2522522522522523,False,False,0.0,False
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]
","        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
",,,"        red = convolve(red, kernel)",0.0,False,True,0.0,False
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim","    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
"," in [2, 3]",    assert image.ndim,    assert kernel.ndim == 2,31.11635626496749,False,True,0.6,False
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stri","

def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
","de * kernel, axis=(2, 3))",    return np.sum(stri,"                * stride, axis=2)",23.616809640565585,False,False,0.5454545454545454,False
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = g","    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
",et_center(kernel),    center = g,    kernel = np.array(kernel),29.88262118900552,False,True,0.25,False
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]
","        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
",,,"        red = convolve(red, kernel)",0.0,False,True,0.0,False
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth,","    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
"," alpha, beta, maximize):","def minimax(board, color, depth,","        alpha, beta, maximize, alpha_max, beta_max, not_maximize",44.28318585712338,False,True,0.3529411764705882,False
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_","
                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",fig = figure,                            best_,"            return best_score, (best_fig, best_move)",36.29385190126103,False,False,0.4,False
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

 ","                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",                       if alpha <= score:, ,            if alpha >= beta:,38.69954552409449,False,False,0.6666666666666666,False
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)
","    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",,,"    # if reached the selected depth, white will be returned",1.1904761904761905,False,True,0.0,True
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color ","
    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
","= ""white""",        opponent_color ,"    # if color == ""black"":",21.213357622017977,False,True,0.3333333333333333,False
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)
","    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",,,"    # if depth is 0, blacks score will be returned",1.366120218579235,False,True,0.0,True
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
","    return best_score, (best_fig, best_move)
",,,        if maximize:,2.380952380952381,False,False,0.0,False
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                   ","                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",     if alpha <= score:,                   ,        if maximize:,8.393956351426972,False,False,0.4,False
