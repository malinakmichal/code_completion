preffix,suffix,label,result,CHRF,exact_match,correct_syntax,correct_code,rougeL
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)
","    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochách
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",    # dopredny chod,"    def forward(self, x):",5.868544600938968,False,False,False,0.0
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochách
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)","            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",        if self.dropout_prob:,        x = F.relu(self.conv1_drop(x)),23.58290417257619,False,True,False,0.1818181818181818
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochách
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    ","model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",,,0.0,nan,nan,True,0.0
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:","        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochách
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",            x = self.drop(x),            x = self.drop(x),100.0,True,True,True,1.0
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x","

model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochách
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",    ,,0.0,False,True,True,0.0
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    ","
model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochách
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",,,0.0,nan,nan,True,0.0
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt","import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochách
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    

model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",from torch import nn,import torch,42.506114653558136,False,True,False,0.3333333333333333
"import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from torch import nn
import torch.nn.functional as F
import torch.utils.data
import matplotlib.pyplot as plt
import Network

data = pd.read_csv(""train.csv"")

label = data['label']
img = data.drop('label', axis=1)
img_tensor = np.array(img).reshape(-1, 1, 32, 32)

dataset = torch.utils.data.TensorDataset(torch.tensor(img_tensor, dtype = torch.float).to(""cuda""), torch.tensor(label, dtype = torch.long).to(""cuda""))
generator = torch.Generator().manual_seed(17)
train_data, val_data, test_data = torch.utils.data.random_split(dataset, [0.7, 0.15, 0.15], generator)

training_loader = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)
validation_loader = torch.utils.data.DataLoader(val_data, batch_size=128, shuffle=False)
testing_loader = torch.utils.data.DataLoader(test_data, batch_size=128, shuffle=False)
        

class DenseNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.fc1 = nn.Linear(32*32, 32)
        self.fc2 = nn.Linear(32, 16)
        self.drop = nn.Dropout(p=dropout_prob)
        self.fco = nn.Linear(16, 10)

    # dopredny chod
    def forward(self, x):
        x = x.flatten(start_dim = 1)
        x = F.relu(self.fc1(x))
        if self.dropout_prob != 0:
            x = self.drop(x)
        x = F.relu(self.fc2(x))
        x = self.fco(x)
        return x
    


model_dense = DenseNetwork(training_loader, validation_loader).to(""cuda"")
model_dense.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_dense.parameters()))
# 50 epoch, early stopping po 10 epochách
model_dense.train(50, 10)


class ConvNetwork(Network):
    def __init__(self, training_loader, validation_loader, alpha=0, dropout_prob=0):
        super().__init__(training_loader, validation_loader, alpha, dropout_prob)
        self.conv1 = nn.Conv2d(in_channels = 1, out_channels = 32, kernel_size = 3)
        self.pool1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.conv1_drop = nn.Dropout2d(p=dropout_prob)
        self.conv2 = nn.Conv2d(32, 16, 3)
        self.pool2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        self.fco = nn.Linear(576, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        if self.dropout_prob:
            x = self.conv1_drop(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)
        x = x.flatten(start_dim = 1)
        x = self.fco(x)
        return x
    ","model_conv = ConvNetwork(training_loader, validation_loader).to(""cuda"")
model_conv.set_parameters(torch.nn.CrossEntropyLoss(), torch.optim.Adam(model_conv.parameters()))
model_conv.train(50, 10)",,,0.0,nan,nan,True,0.0
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60","    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",    X = data.drop(columns='days'),    X = data['days'].dt.total_seconds() / 60,32.86714983231312,False,True,False,0.5
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from sklearn.linear_model import Ridge","def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",,,0.0,nan,nan,True,0.0
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60","    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",    X = data.drop(columns='days'),    X = data['days'].dt.total_seconds() / 60,32.86714983231312,False,True,False,0.5
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error","import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",import math,from sklearn.metrics <|endoftext|>,9.25925925925926,False,False,False,0.0
from sklearn.linear_model import LinearRegression,"from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",from sklearn.model_selection import train_test_split,,0.8375209380234507,False,True,False,0.0
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from sklearn.linear_model import Ridge
","    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",def get_model(data):,,2.109704641350211,False,True,False,0.0
from sklearn.linear_model import LinearRegression,"from sklearn.metrics import mean_absolute_error, mean_squared_error
import math
import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)",from sklearn.model_selection import train_test_split,,0.8375209380234507,False,True,False,0.0
"from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split","import math
import pandas as pd
from sklearn.linear_model import Ridge

def get_model(data):
    y = data['days'].dt.total_seconds() / 60
    X = data.drop(columns='days')
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    model = Ridge().fit(X_train, y_train)

    y_pred = model.predict(X_test)
    acc = mean_absolute_error(y_pred, y_test)
    coef = model.coef_
    print(""Acc:"", acc)
    print(""Coefs:"", coef)

if __name__ == ""__main__"":
    interested = pd.read_csv(""data.csv"")
    get_model(interested)","from sklearn.metrics import mean_absolute_error, mean_squared_error",from sklearn.metrics <|endoftext|>,32.673330842259915,False,False,False,0.4285714285714285
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]
","        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
","        red = convolve(red, kernel)","        red = convolve(red, kernel)",100.0,True,True,True,1.0
"'''Filter'''
import numpy as np
","    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
",def get_center(kernel):,,0.0,False,True,False,0.0
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)",,    return result,    return result,100.0,True,False,True,1.0
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]

","    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
","def get_padding(center, kernel):","def get_padding(center, kernel):",100.0,True,False,True,1.0
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])","
def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
",,,0.0,nan,nan,True,0.0
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)","        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
",,"        red = np.clip(red, 0, 255)",0.0,False,True,True,0.0
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]

        red = convolve(red, kernel)
        blue = convolve(blue, kernel)","
        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
","        green = convolve(green, kernel)","        green = convolve(green, kernel)",100.0,True,True,True,1.0
"'''Filter'''
import numpy as np

def get_center(kernel):
    '''Function that gets the center of the kernel'''
    if kernel.shape[0] % 2 == 1 and kernel.shape[1] % 2 == 1:
        return [kernel.shape[0]//2, kernel.shape[1]//2]
    return [0, 0]


def get_padding(center, kernel):
    '''Gets number of zeros to be padded in each direction'''
    if center == [0,0]:
        return ((1,1),(1,1))
    return (center[0], kernel.shape[0]-1-center[0]), (center[1], kernel.shape[1]-1-center[1])


def convolve(array, kernel):
    '''Applies convolution to a array'''
    center = get_center(kernel)
    padding = get_padding(center, kernel)
    pad_image = np.pad(array, padding)
    sha = (array.shape[0], array.shape[1], kernel.shape[0], kernel.shape[1])
    stride = np.lib.stride_tricks.as_strided(pad_image, shape=sha, strides=pad_image.strides*2)
    return np.sum(stride * kernel, axis=(2, 3))


def apply_filter(image: np.array, kernel: np.array) -> np.array:
    '''Applies filter on a image'''
    assert image.ndim in [2, 3]
    assert kernel.ndim == 2
    assert kernel.shape[0] == kernel.shape[1]
    if len(image.shape) == 3:
        red = image[:, :, 0]
        blue = image[:, :, 1]
        green = image[:, :, 2]","        red = convolve(red, kernel)
        blue = convolve(blue, kernel)
        green = convolve(green, kernel)

        result = np.dstack((red, blue, green))
    else:
        result = convolve(image, kernel)

    result = np.clip(result, 0, 255)
    result = result.astype(np.uint8)
    return result
",,"        red = convolve(red, kernel)",0.0,False,True,False,0.0
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""","        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",    else:,"        opponent_color = ""white""",7.142857142857142,False,True,False,0.0
"from position import Coordinates
from figure import Figure","import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
","from moves import filter_moves, get_score",from filter_moves <|endoftext|>,35.88706585366902,False,False,False,0.5454545454545454
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo","    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",    best_fig = Figure(),    if depth == 0:,5.274261603375527,False,False,False,0.0
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure
","                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",                        if alpha <= score:,            if alpha >= beta:,38.69954552409449,False,False,False,0.6666666666666666
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)
","    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
","    # if reached the selected depth, blacks score will be returned",    for x in range(8):,3.371851630216962,False,False,False,0.0
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:","
    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
","        opponent_color = ""white""",        opponent_color = color,65.16587292595901,False,True,False,0.6666666666666666
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score","                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",,                    if beta <= score:,6.41025641025641,False,False,False,0.0
"from position import Coordinates
from figure import Figure
from moves import filter_moves, get_score
import math


def minimax(board, color, depth, alpha, beta, maximize):
    # with fewer figures depth should be higher todo
    best_fig = Figure()
    best_move = (Coordinates(-1, -1), False)

    # if reached the selected depth, blacks score will be returned
    if depth == 0:
        return get_score(board, ""black""), (best_fig, best_move)

    if color == ""white"":
        opponent_color = ""black""
    else:
        opponent_color = ""white""

    if maximize:
        best_score = -math.inf
    else:
        best_score = math.inf

    for x in range(8):
        for y in range(8):
            if board[x][y].get_type() != ""figure"" and board[x][y].get_color() == color:
                # figure has eligible moves that can be played
                moves = board[x][y].get_moves(board)
                figure = board[x][y]
                moves = filter_moves(moves, board, figure)

                for move in moves:
                    result = figure.move(move, board, True)
                    score = minimax(board, opponent_color, depth - 1, alpha, beta, not maximize)[0]
                    figure.unmake_move(board, result)

                    if maximize:
                        if score > best_score:
                            best_score = score
                            best_move = move
                            best_fig = figure

                        if alpha <= score:
                            alpha = score

                        if alpha >= beta:
                            return best_score, (best_fig, best_move)
                    else:
                        if score < best_score:
                            best_score = score","                            best_fig = figure

                        if beta >= score:
                            beta = score
                        if alpha >= beta:
                            return best_score, (best_fig, best_move)

    return best_score, (best_fig, best_move)
",                            best_move = move,                   <|endoftext|>,4.830917874396136,False,False,False,0.0
